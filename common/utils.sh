#!/bin/bash
#=================================================================================
# This util shell script helps to generate files and provides common functions,
# with this util the main test script looks simple, clear and easy to understand.
#
# Includes:
# 1. generate blueprint file
# 2. generate kickstart file
# 3. generate network definition file
# 4. generate libvirt rule file
# 5. generate ansible inventory file
# 6. check ssh connection
# 7. check if a specific package installed
# 8. wait until compose finish
#
# @Author yih@redhat.com
# @Date: 3/26/2021
#=================================================================================

function greenprint {
    echo -e "\033[1;32m${1}\033[0m"
}

# Write a blueprint for install image.
function _gen_bp_of_install {
tee "$BLUEPRINT_INSTALL_FILE" > /dev/null << EOF
name = "${1}"
description = "A base ostree image"
version = "0.0.1"
modules = []
groups = []
[[packages]]
name = "python36"
version = "*"
EOF
}

# Write a blueprint for upgrade image.
function _gen_bp_of_upgrade {
tee "$BLUEPRINT_UPGRADE_FILE" > /dev/null << EOF
name = "${1}"
description = "An upgrade ostree image"
version = "0.0.2"
modules = []
groups = []
[[packages]]
name = "python36"
version = "*"
[[packages]]
name = "wget"
version = "*"
EOF
}

# Write kickstart file to install edge image
function _gen_ks_file {
tee "$KS_FILE" > /dev/null << STOPHERE
text
lang en_US.UTF-8
keyboard us
timezone --utc Etc/UTC
selinux --enforcing
rootpw --lock --iscrypted locked
user --name=admin --groups=wheel --iscrypted --password=\$6\$1LgwKw9aOoAi/Zy9\$Pn3ErY1E8/yEanJ98evqKEW.DZp24HTuqXPJl6GYCm8uuobAmwxLv7rGCvTRZhxtcYdmC0.XnYRSR9Sh6de3p0
sshkey --username=admin "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCzxo5dEcS+LDK/OFAfHo6740EyoDM8aYaCkBala0FnWfMMTOq7PQe04ahB0eFLS3IlQtK5bpgzxBdFGVqF6uT5z4hhaPjQec0G3+BD5Pxo6V+SxShKZo+ZNGU3HVrF9p2V7QH0YFQj5B8F6AicA3fYh2BVUFECTPuMpy5A52ufWu0r4xOFmbU7SIhRQRAQz2u4yjXqBsrpYptAvyzzoN4gjUhNnwOHSPsvFpWoBFkWmqn0ytgHg3Vv9DlHW+45P02QH1UFedXR2MqLnwRI30qqtaOkVS+9rE/dhnR+XPpHHG+hv2TgMDAuQ3IK7Ab5m/yCbN73cxFifH4LST0vVG3Jx45xn+GTeHHhfkAfBSCtya6191jixbqyovpRunCBKexI5cfRPtWOitM3m7Mq26r7LpobMM+oOLUm4p0KKNIthWcmK9tYwXWSuGGfUQ+Y8gt7E0G06ZGbCPHOrxJ8lYQqXsif04piONPA/c9Hq43O99KPNGShONCS9oPFdOLRT3U= ostree-image-test"
bootloader --timeout=1 --append="net.ifnames=0 modprobe.blacklist=vc4"
network --bootproto=dhcp --device=link --activate --onboot=on
zerombr
clearpart --all --initlabel --disklabel=msdos
autopart --nohome --noswap --type=plain
ostreesetup --nogpg --osname=${1} --remote=${1} --url=${REPO_URL} --ref=${OSTREE_REF}
poweroff
%post --log=/var/log/anaconda/post-install.log --erroronfail
# no sudo password for user admin
echo -e 'admin\tALL=(ALL)\tNOPASSWD: ALL' >> /etc/sudoers
# Remove any persistent NIC rules generated by udev
rm -vf /etc/udev/rules.d/*persistent-net*.rules
# And ensure that we will do DHCP on eth0 on startup
cat > /etc/sysconfig/network-scripts/ifcfg-eth0 << EOF
DEVICE="eth0"
BOOTPROTO="dhcp"
ONBOOT="yes"
TYPE="Ethernet"
PERSISTENT_DHCLIENT="yes"
EOF
echo "Packages within this iot or edge image:"
echo "-----------------------------------------------------------------------"
rpm -qa | sort
echo "-----------------------------------------------------------------------"
# Note that running rpm recreates the rpm db files which aren't needed/wanted
rm -f /var/lib/rpm/__db*
echo "Zeroing out empty space."
# This forces the filesystem to reclaim space from deleted files
dd bs=1M if=/dev/zero of=/var/tmp/zeros || :
rm -f /var/tmp/zeros
echo "(Don't worry -- that out-of-space error was expected.)"
%end
STOPHERE
}

# Write kickstart file of image type rhel-edge-installer
function _gen_ks_file_of_installer {
tee "$KS_FILE" > /dev/null << STOPHERE
text
lang en_US.UTF-8
keyboard us
timezone --utc Etc/UTC
selinux --enforcing
bootloader --timeout=1 --append="net.ifnames=0 modprobe.blacklist=vc4"
network --bootproto=dhcp --device=link --activate --onboot=on
zerombr
clearpart --all --initlabel --disklabel=msdos
autopart --nohome --noswap --type=plain
ostreesetup --nogpg --osname=${1} --remote=${1} --url=file:///ostree/repo --ref=${OSTREE_REF}
poweroff
%post --log=/var/log/anaconda/post-install.log --erroronfail
# Create /var/home/admin user home directory because osbuild can't do that
mkdir -p /var/home/admin/.ssh
cat > /var/home/admin/.ssh/authorized_keys << EOF
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCzxo5dEcS+LDK/OFAfHo6740EyoDM8aYaCkBala0FnWfMMTOq7PQe04ahB0eFLS3IlQtK5bpgzxBdFGVqF6uT5z4hhaPjQec0G3+BD5Pxo6V+SxShKZo+ZNGU3HVrF9p2V7QH0YFQj5B8F6AicA3fYh2BVUFECTPuMpy5A52ufWu0r4xOFmbU7SIhRQRAQz2u4yjXqBsrpYptAvyzzoN4gjUhNnwOHSPsvFpWoBFkWmqn0ytgHg3Vv9DlHW+45P02QH1UFedXR2MqLnwRI30qqtaOkVS+9rE/dhnR+XPpHHG+hv2TgMDAuQ3IK7Ab5m/yCbN73cxFifH4LST0vVG3Jx45xn+GTeHHhfkAfBSCtya6191jixbqyovpRunCBKexI5cfRPtWOitM3m7Mq26r7LpobMM+oOLUm4p0KKNIthWcmK9tYwXWSuGGfUQ+Y8gt7E0G06ZGbCPHOrxJ8lYQqXsif04piONPA/c9Hq43O99KPNGShONCS9oPFdOLRT3U= ostree-image-test
EOF
chown admin:admin /var/home/admin
# no sudo password for user admin
echo -e 'admin\tALL=(ALL)\tNOPASSWD: ALL' >> /etc/sudoers
# Remove any persistent NIC rules generated by udev
rm -vf /etc/udev/rules.d/*persistent-net*.rules
# And ensure that we will do DHCP on eth0 on startup
cat > /etc/sysconfig/network-scripts/ifcfg-eth0 << EOF
DEVICE="eth0"
BOOTPROTO="dhcp"
ONBOOT="yes"
TYPE="Ethernet"
PERSISTENT_DHCLIENT="yes"
EOF
echo "Packages within this iot or edge image:"
echo "-----------------------------------------------------------------------"
rpm -qa | sort
echo "-----------------------------------------------------------------------"
# Note that running rpm recreates the rpm db files which aren't needed/wanted
rm -f /var/lib/rpm/__db*
echo "Zeroing out empty space."
# This forces the filesystem to reclaim space from deleted files
dd bs=1M if=/dev/zero of=/var/tmp/zeros || :
rm -f /var/tmp/zeros
echo "(Don't worry -- that out-of-space error was expected.)"
%end
STOPHERE
}

# Write network definition file
function _gen_network_file {
tee "$NETWORK_FILE" > /dev/null << EOF
<network>
  <name>integration</name>
  <uuid>1c8fe98c-b53a-4ca4-bbdb-deb0f26b3579</uuid>
  <forward mode='nat'>
    <nat>
      <port start='1024' end='65535'/>
    </nat>
  </forward>
  <bridge name='integration' stp='on' delay='0'/>
  <mac address='52:54:00:36:46:ef'/>
  <ip address='192.168.100.1' netmask='255.255.255.0'>
    <dhcp>
      <range start='192.168.100.2' end='192.168.100.254'/>
      <host mac='34:49:22:B0:83:30' name='vm' ip='192.168.100.50'/>
    </dhcp>
  </ip>
</network>
EOF
}

# Write libvirt rule
function _gen_libvirt_rule {
sudo tee /etc/polkit-1/rules.d/50-libvirt.rules > /dev/null << EOF
polkit.addRule(function(action, subject) {
    if (action.id == "org.libvirt.unix.manage" &&
        subject.isInGroup("${WHEEL_GROUP}")) {
            return polkit.Result.YES;
    }
});
EOF
}

# Write ansible inventory file
function _gen_ansible_inventory {
sudo tee "$ANSIBLE_INVENTORY_FILE" > /dev/null << EOF
[ostree_guest]
${GUEST_ADDRESS}
[ostree_guest:vars]
ansible_python_interpreter=/usr/bin/python3
ansible_user=admin
ansible_private_key_file=${SSH_KEY}
ansible_ssh_common_args="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
EOF
}

# check if a package is installed
function _is_pkg_installed {
  cmd="/bin/bash -c \"rpm -qa|grep ${1}\""
  tmpResult=$(sudo ssh "${SSH_OPTIONS[@]}" -i "${SSH_KEY}" admin@"${GUEST_ADDRESS}" "${cmd}")
  if [[ $tmpResult =~ ${1} ]]
  then
    echo 0
  else
    echo 1
  fi
}

# check if ssh is ready on edge image machine
function _wait_ssh_ok {
    greenprint "    Check if ssh to vm ${1}."
    for LOOP_COUNTER in $(seq 0 60); do
	SSH_STATUS=$(sudo ssh "${SSH_OPTIONS[@]}" -i "${SSH_KEY}" admin@"${1}" '/bin/bash -c "echo -n READY"')
	if [[ $SSH_STATUS == READY ]]; then
            break
        fi
        greenprint "    SSH connect failed, will sleep 5 seconds and try again."
        sleep 5
    done

    if [[ $SSH_STATUS == READY ]]
    then
    greenprint "    Successfully ssh to vm ${1}."
    else
    greenprint "    Failed ssh to vm ${1} in 5 minutes, aboart testing!"
    exit 1
    fi
}

# Wait for compose job to complete
function _wait_compose_finish {
    greenprint "===>Check compose status"
    #Wait for compose to complete
    timeCount=0
    while true; do
    sudo composer-cli --json compose info "${1}" | tee "${COMPOSE_INFO_FILE}" > /dev/null
    COMPOSE_STATUS=$(jq -r '.queue_status' "${COMPOSE_INFO_FILE}")

    # Check compose status, if it is not RUNNING or WAITING, break, otherwise will wait 30 seconds and try again.
    if [[ $COMPOSE_STATUS != RUNNING ]] && [[ $COMPOSE_STATUS != WAITING ]]; then
        break
    fi
    sleep 30
    timeCount=`expr ${timeCount} + 1`
    if [[ $timeCount -gt 120 ]]
    then
        greenprint "    Time out!!! Compose didn't finish in 60 minutes, abort testing!"
        exit 1
    fi
    echo "    Compose status is $COMPOSE_STATUS, wait 30 seconds and check again, check time $timeCount"
    done

    #Compose finished, exit script if status is not finished
    if [[ $COMPOSE_STATUS != FINISHED ]]; then
        greenprint "    Failed to compose edge image $1."
        exit 1
    fi
    greenprint "    Successfully composed edge image $1."
}